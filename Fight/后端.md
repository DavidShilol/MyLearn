## Python

### ORM

Object-Relation Mapping，作用是在关系数据库和对象之间做一层映射。ORM将业务逻辑和数据逻辑分离，无需再操作千篇一律的SQL操作，用操作对象的思想去完成业务逻辑。

### 装饰器

装饰器能修改其他的函数，能够在不改变函数名和入参的前提下对函数做变动。

```python
import functools


def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print('call %s():' % func.__name__)
        print('args = {}'.format(*args))
        return func(*args, **kwargs)

    return wrapper
  
@log
def test(p):
    print(test.__name__ + " param: " + p)
```

### Unicode与UTF8

unicode包含了字符集定义与编码方案，UTF8是unicode标准的具体实现，是一种编码方式。UTF8为变长编码，需要1-3字节表示文字。

UTF8优点：

+ 能表示非常大的字符集
+ 占用空间小

缺点：

+ 寻找第N个字符复杂度为O(n)，相比于定长编码，无法通过偏移量定位，只能遍历确认每个字符的编码长度后推算

## 数据库

### MySQL备份

根据备份时数据库的运行状态可分为：

+ 热备份：不影响读写操作
+ 温备份：只可执行读操作，不可写
+ 冷备份：数据库下线，不可读写

MyISAM不支持热备份，InnoDB都支持。

备份的方式分为两种：

+ 物理备份：cp，tar
+ 逻辑备份：使用特定工具导出数据并另存备份，如mysqldump、lvm2、xtrabackup

### MyISAM与InnoDB

+ InnoDB支持事务
+ InnoDB支持外键
+ InnoDB是聚集索引
+ InnoDB不保存表行数
+ InnoDB最小的锁粒度是行锁，MyISAM最小的锁力度是表锁

### 聚集索引与非聚集索引

聚集索引

+ 聚集索引的列排序必须与数据的物理地址顺序一致
+ 建表时默认会创建聚集索引，最好在建表时定义索引，否则会根据索引排序移动数据行的顺序
+ 索引的叶子节点就是数据节点

非聚集索引

+ 叶子节点仍然是索引，索引中包含指向数据文件地址的指针
+ 普通的查询需要进行二次查询才能获取到数据节点
+ 如果查询涉及到索引中不包含的列，需要建立复合索引，才能避免多次查询的问题

## 网络

### 短链接

短链接就是把一个普通的url变成一个较短的url。在限制字符数的场景中，使用短链接能减少url的长度且简洁美观。

短链接的使用过程：用户访问短链接(如http://t.cn/xxxxxx)，请求t.cn对应的服务器，参数为xxxxxx，该服务器在数据库中搜索参数对应的网址，然后使用http 301/302跳转到目标网址。

**自增序列算法**

设置id自增，一个id对应一个url，将十进制的id转换为更高进制的值作为短链接的参数。

**hash**

1. 将长网址 `md5` 生成 128 位的二进制签名串，串分为 4 段，每段 4 个字节
2. 对这四段循环处理，取 4个字节, 将他看成 16 进制串与 0x3fffffff(30位1) 与操作，即超过 30 位的忽略处理
3. 这 30 位分成 6 段，每 5 位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串
4. 总的 `md5` 串可以获得 4 个 6 位串，取里面的任意一个就可作为这个长 url 的短 url 地址

hash算法会存在冲突，但概率很小。

### SSO(Single Sign on)

SSO即单点登录，含义是只需要登录一次，就可以访问互相信任的应用系统。

SSO与传统的登录认证流程不同的是，SSO设置了CAS(Central Authentication Service)，又称为SSO系统，专门用于登录认证，所有业务系统的认证都会跳转到SSO系统进行认真。

SSO认证过程：

1. 用户访问app系统，app系统是需要登录的，但用户现在没有登录。
2. 跳转到CAS server，即SSO登录系统，**以后图中的CAS Server我们统一叫做SSO系统。** SSO系统也没有登录，弹出用户登录页。
3. 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。
4. SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。
5. app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。
6. 验证通过后，app系统将登录状态写入session并设置app域下的Cookie。

至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。

1. 用户访问app2系统，app2系统没有登录，跳转到SSO。
2. 由于SSO已经登录了，不需要重新登录认证。
3. SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。
4. app2拿到ST，后台访问SSO，验证ST是否有效。
5. 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。

### HTTP 301与302的区别

301 是永久重定向，302暂时重定向

301情景：域名到期、空间服务器更换时等。

302情景：暂时想展示另一个网址的内容。

使用302的潜在风险：一、A暂时重定向到B，搜索引擎虽然抓取的是B内容，但是实际收录的A的网址，这导致A蹭了B的热度，搜索排名上升；二、A自己的内容很烂，就重定向到B，相当于于空手套白狼。

### SSL(Secure Sockets Layer)

SSL是Netscape公司提出的安全协议，利用数据加密、身份验证和消息完整性验证机制，为HTTP传输提供安全性保证。

### TCP慢启动

慢启动是拥塞控制的手段之一，通过设置一个**拥塞窗口(cwnd)**，从而避免大包积压在拥塞的节点。

过程：对于一个刚建立的链接，在三次握手期间接收方通告自己的**接收窗口(rwnd)**，发送方通告自己的**拥塞窗口(cwnd)**，拥塞窗口的初始值通常为4个TCP段，发送端取`min(rwnd, cwnd)`作为发送方的滑动窗口大小，在发送完4个段后拥塞窗口增大一点，之后每次传输完部分数据，拥塞窗口就增大一点。这就是慢启动的过程，尽管带宽足够大仍然受慢启动的影响，在新连接的流量被限制。

TCP的另一机制叫**SSR(Slow-StartRestart)慢启动重启**：在连接空闲一定的时间后重置连接的拥塞窗口。

### HTTP keep-alive

http的keep-alive机制用于延长tcp的连接状态，从最后一次响应结束开始计时keep-alive时间长度，之后如果没有再收到消息将主动发送[FIN, ACK]。tcp连接的双方都有http keep-alive计时，谁时间短谁就先发出关闭消息。

http的keep-alive机制从http 1.1才出现，默认为keep-alive连接。在http 1.0之前每次发送完数据就会断开tcp连接，导致tcp连接的使用非常低效。在keep-alive机制下一个tcp连接能传多个数据。

### TCP keep-alive

有别于HTTP keep-alive，TCP的keep-alive存在的意义是检测对方是否还在。TCP的keep-alive机制有三个参数：闲置时间、侦测包发送时间间隔、侦测包发送次数。在最后一次双方交互数据后开始计时闲置时间，之后如果没有新的交互数据，就会发送侦测包看看对方的回应，如果没有回应就在一定时间间隔后再次发送，总共发送一定次数的侦测包，最终因为无回应而主动关闭TCP连接。

### HTTPS

**与HTTP有什么区别？**

传统的HTTP协议直接与TCP协议进行通讯；HTTPS则是在HTTP与TCP之间增加SSL/TSL(*Secure Sockets Layer/Transport Layer Security*)对数据加密。

**HTTPS工作过程？**

+ 握手阶段(一次握手)

  1.客户端发起握手。*明文传输版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息*。

  2.服务端返回协商结果。*包括选择使用的协议版本 version，选择的加密套件 cipher suite，选择的压缩算法 compression method、随机数 random_S 以及数字证书*。

  3.客户端SSL/TLS验证数字证书的合法性。*验证过程看下一个问题。*

  4.客户端随机生成对称密钥。*传输过程用服务器公钥和商定的加密套件进行加密。*

  5.服务端用密钥解密获取对称密钥，并发送加密的Finish信息。*握手结束。*

+ 通信阶段

  双方使用对称密钥对HTTP数据加密和解密。

**如何验证数字证书的合法性？**

数字证书=认证内容+CA数字签名+Hash序列

认证内容=服务端公钥+签发者+证书到期时间+加密算法+证书用途

CA数字签名=CA密钥(Hash(认证内容))

客户端拿到数字证书，CA数字签名---(CA公钥)--->信息摘要，Compare(Hash(认证内容),  信息摘要)，一致则说明证书合法。

**为什么握手阶段的交互用非对称加密，通信阶段的交互用对称加密**

非对称加密的计算复杂度大于对称加密，字符串越长耗时越长，通信阶段使用对称加密可节约硬件资源的占用。

### Cookie & Session

**cookie**：服务器在本地机器上存储的一小段文本并随每一次请求发送给同一个服务器。cookie分为暂时cookie和永久cookie，取决于是否设置了过期时间。暂时cookie存在于浏览器所占用的内存中，永久cookie以文件形式存储在硬盘中直到过期。

**session**：服务器中一种用于存放用户数据的类HashTable结构。浏览器在第一次请求服务器时，会生成HashTable和session ID。

**两者区别？**

存放位置不同，cookie存储在客户端，session存储在服务端；

存储类型不同，cookie存储字符串，session存储Object类型；

安全性不同，cookie有可能被拦截获取或被篡改，session则不会被截获；

### [CORS](http://www.ruanyifeng.com/blog/2016/04/cors.html)

**跨域资源共享的背景**：有些资源只允许同域或授权的域名才可以访问。

浏览器：所有浏览器都支持跨域请求，通信过程自动完成。

服务器：需要设置CORS接口才允许跨域请求。

### 网络体系结构

**OSI七层协议**：物理层、数据链路层、网络层、运输层、会话层、表示层、应用层

**TCP/IP四层协议**：网络接口层、网际层、运输层、应用层

通常，综合OSI与TCPIP的优点使用五层协议的体系结构。具体为：物理层、数据链路层、网络层、运输层、应用层。一般为了方便，把网络层底下的两层称为网络接口层。

**各层协议举例**：

+ 应用层：TELNET、FTP、SMTP
+ 运输层：TCP、UDP
+ 网络层：IP、ICMP

### 传输层

#### UDP

**特点**

+ UDP是无连接的，即发送数据前无需建立连接。
+ UDP使用尽最大努力交付，即不保证可靠交付，主机无需维持复杂的连接状态。
+ UDP是面向报文的，对应用程序传下来的数据在添加首部后就交给IP层，IP层交上来的数据在去掉首部后就交给应用程序。
+ UDP没有拥塞控制，网络拥塞不会降低源主机的发送速率。
+ UDP支持一对一、一对多、多对一和多对多的交互通信。
+ UDP的首部开销小，只有8字节。

**UDP数据报内容**

首部字段+数据字段

**首部格式**

+ 源端口(2字节)：需要对方回信时选用，不需要时为全0.
+ 目的端口(2字节)
+ 长度(2字节)：UDP数据报的长度，最小值为8字节(只有首部字段)。
+ 校验和(2字节)：UDP检验和是将整个UDP数据报进行校验。

#### TCP的连接建立

+ 被动方创建传输控制块，进入Listen(监听)状态

+ 主动方创建传输控制块，发出连接请求报文，SYN=1；seq=x，进入SYN-SENT(同步已发送)

+ 被动方收到连接报文，返回确认报文，SYN=1；seq=y；ACK=1；ack=x+1，进入SYN-RCVD(同步收到)

+ 主动方收到确认报文，返回确认报文，seq=x+1；ACK=1；ack=y+1，进入ESTABLISHED(建立连接)

  *当主动方返回的确认报文中携带数据，将消耗自己的一个序号*

+ 被动方收到确认报文，进入ESTABLISHED(建立连接)

**为什么要三次握手？**

如果没有第三次握手，被动方直接进入ESTABLISHED，一直等待主动方发数据，造成资源浪费。

#### TCP的连接释放

+ 主动方发出释放报文，FIN=1；seq=u，进入FIN-WAIT-1(终止等待1)

  *FIN报文段必须消耗一个序号*

  *seq=u，u是主动方前面已传送过的数据的最后一个字节的序号加1*

+ 被动方收到释放报文，返回确认报文，seq=v；ACK=1；ack=u+1，进入CLOSE-WAIT(关闭等待)

  *seq=v，v是被动方前面已传送过的数据的最后一个字节的序号加1*

  *CLOSE-WAIT后，主动->被动方向的连接已经关闭*

  *CLOSE-WAIT后，被动方的TCP层通知上层的进程，把最后的数据发送出去*

+ 主动方收到确认报文，进入FIN-WAIT-2(终止等待2)

+ 被动方上层进程发送最后的数据，通知TCP层去发送释放报文，FIN=1；seq=w；ACK=1；ack=u+1，进入LAST-ACK(最后确认)

+ 主动方收到释放报文，返回确认报文，seq=u+1；ACK=1；ack=w+1，并开始倒计时2MSL

  *2MSL内，如果遇到被动方重传释放报文则重置计时器并再次返回确认报文，否则时间耗尽进入CLOSED*

+ 被动方收到确认报文，进入CLOSED

**第四次挥手为什么要等待2MSL？**

原因一：为了保证第四次挥手报文到达被动方。如果被动方收不到确认报文，被动会重传释放报文，主动方如果等待2MSL就肯定能接收到重传报文。

原因二：保证下一个新连接不会不会出现旧连接的报文。主动方发送确认报文后的2SML内，本次连接产生的所有报文都会从网络中消失。

#### TCP可靠传输的原理

+ 滑动窗口：控制数据传输速率；
+ 超时重传：保证分组到达；
+ 选择确认：减少重传，提高效率；(多数发送方可能不会对选择确认进行回应，仍然会重传)

#### TCP滑动窗口协议

含义：规定TCP传输过程一次发送多少字节的数据，滑动窗口协议是在TCP协议中使用的。

用途：端到端的流量控制。

特性：滑动窗口大小在TCP三次握手后进行协商，传输过程中数据按顺序发送并按顺序确认后，窗口才向后滑动。滑动窗口协议解决了网络传输不可靠的问题，如丢包、重复包、乱序。

原理：

数据包分为四类：已发送、已发送未确认、允许发送未发送、不可发送。发送方和接收方分别维护一个缓冲区，即窗口。缓冲区内的数据将按顺序发送并按顺序确认。

正常情况下，当收到缓冲区第一个数据包的ACK时窗口向后滑动一个位置，新的数据放入缓冲区准备发送。

如果丢包，缓冲区第一个字节的数据在**超时重传**机制下会重传。在拿到该字节的确认之后，窗口后移一位。

**如果发送方第二个字节先到达怎么办？**

假设接收方拿到了第二个字节的数据，但第一个字节的数据还没收到，这时接收方会将第二个字节保留在缓冲区。

发送方如果没收到第一个字节的确认，会超时重传。重传后发送方收到了第一个字节的确认，因为第二个字节早已在缓冲区中，接收方发送完第一个字节的确认，便可以立即发送第二个字节的确认。

如果第二个字节的确认还在路上，发送方那就超时了，发送方就会重传第二个字节。

#### TCP的拥塞控制

含义：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞的定义为：`需求的资源>可用的资源`。

特性：拥塞控制涉及网络中所有的主机、路由器，是全局性的控制。

原理：网络拥塞是所有因素影响的加成，解决单点拥塞没有意义，甚至会更加拥塞。需要从全局综合考虑，分为开环控制和闭环控制。开环即事先设计好方案，系统一旦运行则不可更改。闭环则是基于反馈的自动调整。

方法：慢开始、拥塞避免、快重传、快恢复。

+ 慢开始
  + 开始传输，设置初始拥塞窗口值，即首次发送的字节数。*拥塞窗口以字节为单位，数值一般为1-4个SMSS(最大报文段)，拥塞窗口限制的是一次发送的所有报文段的字节大小之和，其实也可以理解为一个轮次能发送的报文个数。*
  + 接收到一个确认报文，拥塞窗口就会增加，下一轮次发送的总报文大小为增加后的窗口值。*`窗口的增加值=min(N, SMSS)`，N为原先未确认、刚刚收到确认报文所确认的字节数。*
  + 传输轮次并非一轮轮地发送报文，每收到一个确认报文就可以立即发送新报文，轮次概念能很好地体现数据的按序发送和确认。一轮传输所用的时间称为**RTT**，等于从发出该轮次第一个报文至该接收到该轮次最后一个报文的时间。
+ 拥塞避免
  + 拥塞窗口持续增加，会造成网络的拥塞，因此需要设置**慢开始门限**。当拥塞窗口>门限，将停止慢开始算法，改用拥塞避免算法。
  + 每经历一个RTT，拥塞窗口增加1。
  + 假设拥塞窗口值=n时接收方的确认包发生超时，发送方将门限设置为当前窗口的n/2，同时把拥塞窗口重置为初始拥塞窗口值，重新进入慢开始阶段。
+ 快重传
  + 传输中总会有丢包的情况，但网络中并没有发生拥塞。如果没有收到确认报文，发送方会认为网络拥塞而重置拥塞窗口，降低了传输效率。
  + 快重传要求接收方在收到报文后，立即发送确认报文。在发生丢包时，假设M2在传输中丢失，当M3、M4、M5到达时，都要立即发送M1的确认报文，发送方会收到4个重复确认。按规定：收到3个连续的M1重复确认报文，就需要重传M2。
+ 快恢复
  + 发送方接收到3个连续的重复确认，便将门限设置为当前窗口的n/2，同时把窗口值也设置为当前窗口的n/2，从而避免了进入慢开始阶段，提高了传输效率。

### URL解析过程

浏览器输入URL后，经历以下过程后将域名转换成IP：

+ 浏览器查看自己的DNS缓存
+ 递归调用操作系统DNS缓存
+ 递归调用本地域名服务器
+ 本地域名服务器向根域名服务器请求
+ 本地域名服务器向com域名服务器请求
+ 本地域名服务器向权限域名服务器请求

上述顺序中，只要有一步找到域名，便可结束查询。

## 操作系统

### 异常

异常是异常控制流(EOF, Exception control flow)中的突变，用来响应处理器状态中的某些变化。

**异常表**：跳转表，包含了各种异常处理程序的地址。

当处理器触发事件时，通过间接过程调用，根据异常表跳转到响应的处理程序，当前运行的程序便将控制交给异常处理程序。等异常处理程序执行完成，异常处理程序选择将控制转给被中断的程序或终止被中断的程序。

**异常类别**

| 类别 | 原因              | 异步异常/同步异常 | 返回行为           |
| ---- | ----------------- | ----------------- | ------------------ |
| 中断 | 来自I/O设备的信号 | 异步              | 总是返回下一条指令 |
| 陷阱 | 有意的异常        | 同步              | 总是返回下一条指令 |
| 故障 | 潜在可恢复的错误  | 同步              | 可能返回当前指令   |
| 终止 | 不可恢复的错误    | 同步              | 不会返回           |

异步异常不是由专门的指令造成的异常，陷阱等同步异常是执行当前指令的结果。

陷阱最重要的用途是在用户程序的和内核间提供一个像过程一样的接口，系统调用。系统调用诸如读文件(read)、创建进程(fork)、加载新程序(execve)、终止当前进程(exit)。用户程序通过"syscall n"请求服务n。

### 逻辑控制流

每一个进程都有自己的逻辑控制流，简称逻辑流。

相关名词释义

**并发流**：两个流在执行时间上重叠。

**并发**：多个流并发地执行的一般现象。

**多任务**：多个进程轮流运行。又称为时间分片。

**时间片**：一个进程执行它的控制流的一部分的时间段。

**并行流**：两个流并发地运行在不同的处理器核或计算机上。它们并行地运行，也并行地执行。

### 私有地址空间

每个进程都有独立的私有地址空间。地址空间底部是保留给用户程序的，包括代码、数据、堆、栈段。顶部保留给内核，包括内核在代表进程执行指令时(如应用程序执行系统调用)所使用的代码、数据、堆、栈。

### 进程的创建

UNIX系统中，fork是唯一的系统调用可以用来创建新进程。进程总是由正在运行的进程来创建，父进程所做的工作是：执行一个用来创建新进程的系统调用。这个系统调用通知操作系统创建一个新进程，并且直接或间接指定该进程中运行的程序。

**父子进程的地址空间是一样的吗？**

在UNIX中，调用fork之后两个进程拥有相同的内存映像、环境字符串和打开文件。接着子进程将执行execve或类似的系统调用，以修改其内存映像并运行一个新的程序。

在execve之前，两进程共享所有内存，子进程的地址空间是父进程的一个副本；execve之后，凡是子进程要修改的内存都会被复制一份，然后在新的内存地址上进行修改，即写时复制。

### 进程的三种状态

1.运行态(*某一瞬间进程占用CPU*)

2.就绪态(*可运行，但因为其他进程正在运行而暂时停止*)

3.阻塞态(*除非某种外部事件发生，否则进程不能运行*)

+ 正在运行的进程不能再继续运行时(所需资源暂时不可用)，该进程由运行态进入阻塞态
+ 正在运行的进程因为占用CPU时间过长，系统决定让其他进程使用CPU时间，该进程由运行态进入就绪态
+ 经过一轮公平享有CPU的进程调度后，进程由就绪态进入运行态
+ 阻塞态进程所等待的外部事件发生，进入就绪态；如果此时没有运行态进程，该进程将立即进入运行态

### 信号

信号是高层次的软件形式的异常。信号允许进程

**传送信号到目的进程的两个步骤**

1.发送信号：内核通过更新目的进程上下文中的某个状态，传送一个信号到目的进程

2.接收信号：当目的进程被内核强迫以某种方式对信号做出反应时，就接收了信号

**待处理信号**：发出而没有被接收的信号。*同类型的待处理信号只维持一个，剩下的将会被简单丢弃。*

**设置进程组**：setpgid(pid_t pid, pid_t pgid)。优先取pgid，若为0则取pid，若pid也为0，则取当前进程的pid。

**发送信号的四种方法**

1./bin/kill

2.从键盘发送信号

3.kill函数

kill(pid_t pid, int sig)

+ pid>0, 发送给进程pid

+ pid=0, 发送给调用进程所在的进程组

+ pid<0,发送给进程组|pid|

4.alarm函数

### 虚拟内存相关概念

**物理地址**(Physical Address，PA)：主存被组织成一个由M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的物理地址。

**虚拟地址**(Virtual Address，VA)：CPU通过虚拟地址来访问主存，虚拟地址在送到内存之前先转换成物理地址。

**内存管理单元**(Memory Management Unit，MMU)：CPU芯片上的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表内容由操作系统管理。

**虚拟内存**：被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为数组的索引。

*解读：虚拟内存是一个数组，数组的每一个元素是一个字节大小的单元，每个字节都对应一个虚拟地址。这个数组占用磁盘的空间。换个说法就是，把磁盘按字节分组，通过虚拟地址就能索引到对应的分组。*

**虚拟页**(Virtual Page，VP)：将虚拟内存分割成固定大小的块，每一块就是一个虚拟页，页大小为`P=2^p`字节。

*解读：在虚拟内存技术之前，磁盘与主存之间的交互，就是将数据分块作为传输单元的。虚拟内存技术为了以同样方式传输数据，便将虚拟内存划分为多个虚拟页。*

**物理页**(Physical Page，PP)：物理内存对应地也按P字节划分成数个物理页。

**虚拟页面集合的三种状态**：1.未分配；2.已缓存；3.未缓存。未分配是说虚拟页没有和任何数据相关联。已缓存是说虚拟页分配了关联的数据，并且这些数据已经缓存在物理内存中。

*解读：虚拟页面的集合可以看成一个数组由多个虚拟页构成，`[VP0, VP1, VP2, ...]`。以VP0为例，页大小为P字节，也就是说包含了P个虚拟地址。VP0最终会与某个物理页对应，VP0中的P个虚拟地址也将与该物理页的P个物理地址对应。*

**页表**：将虚拟页映射到物理页，是一个页表条目(Page Table Entry，PTE)的数组。

**页表基址寄存器**(Page Table Base Register, PTBR)：用于指向当前的页表。

**虚拟页面偏移**(Virtual Page Offset, VPO)：用于指向虚拟页中某一个地址。

**虚拟页号**(Virtual Page Number, VPN)：用于指向某一个虚拟页。

### 虚拟页的命中过程

**页命中**

假设CPU想读VP2的某个字，且VP2已经缓存在内存中。此时地址翻译硬件读取页表的PTE2，PTE2显示有效位为1，说明虚拟页已缓存，所以该条目中的地址是物理内存地址。于是它使用此地址构造出了这个字的物理地址。

**缺页**

如果VP2并没有缓存在内存中，PTE2显示有效位为0且不为空，说明虚拟页存在磁盘中。同时这会触发缺页异常，该异常调用内核的缺页异常处理程序，程序选择一个牺牲页如VP4，同时修改该页的页表条目，表示VP4不再缓存在内存中。然后将VP3从磁盘复制到内存中，同时更新PTE3。异常程序将控制交回暂停的程序，继续执行导致缺页的指令，此时便可按页命中的流程进行下去了。

### 地址翻译过程

<img src="/Users/exocr/Library/Application Support/typora-user-images/image-20200726164915680.png" alt="image-20200726164915680" style="zoom:50%;" />

根据PTBR可以获取当前页表；根据VPN确定页表的PTE，如VPN5对应PTE5；根据PTE中的PPN确定对应的物理页的首地址；利用VPO=PPO，可以推算出物理页下具体的物理地址。最终MMU向CPU返回一个物理地址。

上述过程的前提是页命中。

### 写时复制

每个进程都有独立的页表，即独立的虚拟地址空间。

来自不同虚拟地址空间的虚拟地址可以映射到相同的物理地址，即多个地址空间共享了物理地址(又称为对象)。

如果虚拟地址空间的一个区域映射到了共享对象，该区域称为共享区域；反之，映射到私有对象的区域叫做私有区域。

私有对象在生命周期的开始，与共享对象一样，只有一个副本。如果某个进程需要修改虚拟内存且私有对象仍被其他进程共享，对应的PTE显示该页面的权限为只读，将处罚保护故障。故障处理程序在内存中创建该页面的新副本，更新PTE指向新副本，然后恢复页面的可写权限。当故障处理程序返回，再次执行写操作时，就会在新副本上正常执行了。

### 地址空间的内容

<img src="/Users/exocr/Library/Application Support/typora-user-images/image-20200726173824369.png" alt="image-20200726173824369" style="zoom:50%;" />

**栈**：局部临时变量，函数参数，返回地址。

**堆**：动态分配的内存。

**BS段**(.bss)：未初始化且初值非0的全局变量和静态局部变量。

**数据段**(.data)：已初始化且初值非0的全局变量和静态局部变量。

**代码段**(.text)：可执行代码、字符串字面值、只读变量

**简述进程的内存管理？**

每个进程拥有独立的虚拟地址空间，其中包含了代码段、数据段、BS段、堆(heap)、栈(stack)。堆向地址高位扩展、栈向地址地位扩展。堆存放动态分配的区域，栈存放局部临时变量。

### IO多路复用

单个线程管理多个IO流，时分复用

三种实现方式：select、poll、epoll

select：socket注册进select，select轮询并调用被激活的socket，通知用户线程发起读取请求

poll：取消select 1024连接数限制、不修改传入的参数

epoll>poll>select，只有epoll是线程安全

### 栈帧

函数调用，在调用栈维护独立的栈帧，包含内容：

+ 函数参数、返回地址
+ 临时变量
+ 函数调用的上下文

栈由高地址向低地址延伸，ebp寄存器-帧指针-栈底，esp寄存器-栈指针-栈顶。

### 连续/随机内存访问

内存访问时，CPU的cache会载入预测的一段连续内存地址。连续内存访问，能提高cache命中率；随机访问则可能会导致多次载入内存数据到cache，降低cache命中率。

## 其他

### 密码

**1.对称加密**

发送方将明文和密钥经过加密算法处理后，变成密文发送出去。接收方使用相同的密钥和相同算法的逆算法对密文进行解密，才能获取明文。

**2.非对称加密**

加密和解密使用不同的密钥，公钥加密后只能用私钥解密，私钥加密后只能用公钥解密。将公钥分发给多个对象，私有只有自己使用，那么对方发来的消息使用公钥加密后，只有自己才能解密。

**3.数字证书**

数字证书由证书中心(CA)颁发，CA使用自己的私钥将一个公钥和相关信息加密得到数字证书，用于对公钥做认证。

使用场景：

A发送信息需要经过三步：一、使用私钥对明文加密变成密文；二、用Hash函数生成信件摘要(digest)，再使用私钥将摘要加密生成数字签名，附在密文下面；三、向CA申请公钥认证，拿到CA颁布的数字证书，同样附在密文下面。

B接收到消息后，也需要经过三步：一、从数字证书的颁发者那获取CA的公钥，再使用CA公钥对数字证书解密从而拿到A的公钥；二、使用A公钥对数字签名解密从而拿到信件摘要；三、使用A公钥对密文解密从而拿到明文，并对明文做同样的Hash处理，如果Hash结果和拿到的摘要一样则证明数字签名确实是由A签写的。
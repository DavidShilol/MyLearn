[TOC]

## Python

### ORM

Object-Relation Mapping，作用是在关系数据库和对象之间做一层映射。ORM将业务逻辑和数据逻辑分离，无需再操作千篇一律的SQL操作，用操作对象的思想去完成业务逻辑。

### 装饰器

装饰器能修改其他的函数，能够在不改变函数名和入参的前提下对函数做变动。

```python
import functools


def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        print('call %s():' % func.__name__)
        print('args = {}'.format(*args))
        return func(*args, **kwargs)

    return wrapper
  
@log
def test(p):
    print(test.__name__ + " param: " + p)
```

## 数据库



## 网络

### 短链接

短链接就是把一个普通的url变成一个较短的url。在限制字符数的场景中，使用短链接能减少url的长度且简洁美观。

短链接的使用过程：用户访问短链接(如http://t.cn/xxxxxx)，请求t.cn对应的服务器，参数为xxxxxx，该服务器在数据库中搜索参数对应的网址，然后使用http 301/302跳转到目标网址。

**自增序列算法**

设置id自增，一个id对应一个url，将十进制的id转换为更高进制的值作为短链接的参数。

**hash**

1. 将长网址 `md5` 生成 128 位的二进制签名串，串分为 4 段，每段 4 个字节
2. 对这四段循环处理，取 4个字节, 将他看成 16 进制串与 0x3fffffff(30位1) 与操作，即超过 30 位的忽略处理
3. 这 30 位分成 6 段，每 5 位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串
4. 总的 `md5` 串可以获得 4 个 6 位串，取里面的任意一个就可作为这个长 url 的短 url 地址

hash算法会存在冲突，但概率很小。

### SSO(Single Sign on)

SSO即单点登录，含义是只需要登录一次，就可以访问互相信任的应用系统。

SSO与传统的登录认证流程不同的是，SSO设置了CAS(Central Authentication Service)，又称为SSO系统，专门用于登录认证，所有业务系统的认证都会跳转到SSO系统进行认真。

SSO认证过程：

1. 用户访问app系统，app系统是需要登录的，但用户现在没有登录。
2. 跳转到CAS server，即SSO登录系统，**以后图中的CAS Server我们统一叫做SSO系统。** SSO系统也没有登录，弹出用户登录页。
3. 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。
4. SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。
5. app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。
6. 验证通过后，app系统将登录状态写入session并设置app域下的Cookie。

至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。

1. 用户访问app2系统，app2系统没有登录，跳转到SSO。
2. 由于SSO已经登录了，不需要重新登录认证。
3. SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。
4. app2拿到ST，后台访问SSO，验证ST是否有效。
5. 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。

### HTTP 301与302的区别

301 是永久重定向，302暂时重定向

301情景：域名到期、空间服务器更换时等。

302情景：暂时想展示另一个网址的内容。

使用302的潜在风险：一、A暂时重定向到B，搜索引擎虽然抓取的是B内容，但是实际收录的A的网址，这导致A蹭了B的热度，搜索排名上升；二、A自己的内容很烂，就重定向到B，相当于于空手套白狼。

## 其他

### 密码

**1.对称加密**

发送方将明文和密钥经过加密算法处理后，变成密文发送出去。接收方使用相同的密钥和相同算法的逆算法对密文进行解密，才能获取明文。

**2.非对称加密**

加密和解密使用不同的密钥，公钥加密后只能用私钥解密，私钥加密后只能用公钥解密。将公钥分发给多个对象，私有只有自己使用，那么对方发来的消息使用公钥加密后，只有自己才能解密。

**3.数字证书**

数字证书由证书中心(CA)颁发，CA使用自己的私钥将一个公钥和相关信息加密得到数字证书，用于对公钥做认真。

使用场景：

A发送信息需要经过三步：一、使用私钥对明文加密变成密文；二、用Hash函数生成信件摘要(digest)，再使用私钥将摘要加密生成数字签名，附在密文下面；三、向CA申请公钥认证，拿到CA颁布的数字证书，同样附在密文下面。

B接收到消息后，也需要经过三步：一、从数字证书的颁发者那获取CA的公钥，在使用CA公钥对数字证书解密从而拿到A的公钥；二、使用A公钥对数字签名解密从而拿到信件摘要；三、使用A公钥对密文解密从而拿到明文，并对明文做同样的Hash处理，如果Hash结果和拿到的摘要一样则证明数字签名确实是由A签写的。
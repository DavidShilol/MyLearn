[toc]

### 异常

异常是异常控制流(EOF, Exception control flow)中的突变，用来响应处理器状态中的某些变化。

**异常表**：跳转表，包含了各种异常处理程序的地址。

当处理器触发事件时，通过间接过程调用，根据异常表跳转到响应的处理程序，当前运行的程序便将控制交给异常处理程序。等异常处理程序执行完成，异常处理程序选择将控制转给被中断的程序或终止被中断的程序。

**异常类别**

| 类别 | 原因              | 异步异常/同步异常 | 返回行为           |
| ---- | ----------------- | ----------------- | ------------------ |
| 中断 | 来自I/O设备的信号 | 异步              | 总是返回下一条指令 |
| 陷阱 | 有意的异常        | 同步              | 总是返回下一条指令 |
| 故障 | 潜在可恢复的错误  | 同步              | 可能返回当前指令   |
| 终止 | 不可恢复的错误    | 同步              | 不会返回           |

异步异常不是由专门的指令造成的异常，陷阱等同步异常是执行当前指令的结果。

陷阱最重要的用途是在用户程序的和内核间提供一个像过程一样的接口，系统调用。系统调用诸如读文件(read)、创建进程(fork)、加载新程序(execve)、终止当前进程(exit)。用户程序通过"syscall n"请求服务n。

### 逻辑控制流

每一个进程都有自己的逻辑控制流，简称逻辑流。

相关名词释义

**并发流**：两个流在执行时间上重叠。

**并发**：多个流并发地执行的一般现象。

**多任务**：多个进程轮流运行。又称为时间分片。

**时间片**：一个进程执行它的控制流的一部分的时间段。

**并行流**：两个流并发地运行在不同的处理器核或计算机上。它们并行地运行，也并行地执行。

### 私有地址空间

每个进程都有独立的私有地址空间。地址空间底部是保留给用户程序的，包括代码、数据、堆、栈段。顶部保留给内核，包括内核在代表进程执行指令时(如应用程序执行系统调用)所使用的代码、数据、堆、栈。

### 进程的创建

UNIX系统中，fork是唯一的系统调用可以用来创建新进程。进程总是由正在运行的进程来创建，父进程所做的工作是：执行一个用来创建新进程的系统调用。这个系统调用通知操作系统创建一个新进程，并且直接或间接指定该进程中运行的程序。

**父子进程的地址空间是一样的吗？**

在UNIX中，调用fork之后两个进程拥有相同的内存映像、环境字符串和打开文件。接着子进程将执行execve或类似的系统调用，以修改其内存映像并运行一个新的程序。

在execve之前，两进程共享所有内存，子进程的地址空间是父进程的一个副本；execve之后，凡是子进程要修改的内存都会被复制一份，然后在新的内存地址上进行修改，即写时复制。

### 进程的三种状态

1.运行态(*某一瞬间进程占用CPU*)

2.就绪态(*可运行，但因为其他进程正在运行而暂时停止*)

3.阻塞态(*除非某种外部事件发生，否则进程不能运行*)

+ 正在运行的进程不能再继续运行时(所需资源暂时不可用)，该进程由运行态进入阻塞态
+ 正在运行的进程因为占用CPU时间过长，系统决定让其他进程使用CPU时间，该进程由运行态进入就绪态
+ 经过一轮公平享有CPU的进程调度后，进程由就绪态进入运行态
+ 阻塞态进程所等待的外部事件发生，进入就绪态；如果此时没有运行态进程，该进程将立即进入运行态

### 信号

信号是高层次的软件形式的异常。信号允许进程

**传送信号到目的进程的两个步骤**

1.发送信号：内核通过更新目的进程上下文中的某个状态，传送一个信号到目的进程

2.接收信号：当目的进程被内核强迫以某种方式对信号做出反应时，就接收了信号

**待处理信号**：发出而没有被接收的信号。*同类型的待处理信号只维持一个，剩下的将会被简单丢弃。*

**设置进程组**：setpgid(pid_t pid, pid_t pgid)。优先取pgid，若为0则取pid，若pid也为0，则取当前进程的pid。

**发送信号的四种方法**

1./bin/kill

2.从键盘发送信号

3.kill函数

kill(pid_t pid, int sig)

+ pid>0, 发送给进程pid

+ pid=0, 发送给调用进程所在的进程组

+ pid<0,发送给进程组|pid|

4.alarm函数

### 虚拟内存相关概念

**物理地址**(Physical Address，PA)：主存被组织成一个由M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的物理地址。

**虚拟地址**(Virtual Address，VA)：CPU通过虚拟地址来访问主存，虚拟地址在送到内存之前先转换成物理地址。

**内存管理单元**(Memory Management Unit，MMU)：CPU芯片上的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表内容由操作系统管理。

**虚拟内存**：被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为数组的索引。

*解读：虚拟内存是一个数组，数组的每一个元素是一个字节大小的单元，每个字节都对应一个虚拟地址。这个数组占用磁盘的空间。换个说法就是，把磁盘按字节分组，通过虚拟地址就能索引到对应的分组。*

**虚拟页**(Virtual Page，VP)：将虚拟内存分割成固定大小的块，每一块就是一个虚拟页，页大小为`P=2^p`字节。

*解读：在虚拟内存技术之前，磁盘与主存之间的交互，就是将数据分块作为传输单元的。虚拟内存技术为了以同样方式传输数据，便将虚拟内存划分为多个虚拟页。*

**物理页**(Physical Page，PP)：物理内存对应地也按P字节划分成数个物理页。

**虚拟页面集合的三种状态**：1.未分配；2.已缓存；3.未缓存。未分配是说虚拟页没有和任何数据相关联。已缓存是说虚拟页分配了关联的数据，并且这些数据已经缓存在物理内存中。

*解读：虚拟页面的集合可以看成一个数组由多个虚拟页构成，`[VP0, VP1, VP2, ...]`。以VP0为例，页大小为P字节，也就是说包含了P个虚拟地址。VP0最终会与某个物理页对应，VP0中的P个虚拟地址也将与该物理页的P个物理地址对应。*

**页表**：将虚拟页映射到物理页，是一个页表条目(Page Table Entry，PTE)的数组。

**页表基址寄存器**(Page Table Base Register, PTBR)：用于指向当前的页表。

**虚拟页面偏移**(Virtual Page Offset, VPO)：用于指向虚拟页中某一个地址。

**虚拟页号**(Virtual Page Number, VPN)：用于指向某一个虚拟页。

### 虚拟页的命中过程

**页命中**

假设CPU想读VP2的某个字，且VP2已经缓存在内存中。此时地址翻译硬件读取页表的PTE2，PTE2显示有效位为1，说明虚拟页已缓存，所以该条目中的地址是物理内存地址。于是它使用此地址构造出了这个字的物理地址。

**缺页**

如果VP2并没有缓存在内存中，PTE2显示有效位为0且不为空，说明虚拟页存在磁盘中。同时这会触发缺页异常，该异常调用内核的缺页异常处理程序，程序选择一个牺牲页如VP4，同时修改该页的页表条目，表示VP4不再缓存在内存中。然后将VP3从磁盘复制到内存中，同时更新PTE3。异常程序将控制交回暂停的程序，继续执行导致缺页的指令，此时便可按页命中的流程进行下去了。

### 地址翻译过程

<img src="/Users/exocr/Library/Application Support/typora-user-images/image-20200726164915680.png" alt="image-20200726164915680" style="zoom:50%;" />

根据PTBR可以获取当前页表；根据VPN确定页表的PTE，如VPN5对应PTE5；根据PTE中的PPN确定对应的物理页的首地址；利用VPO=PPO，可以推算出物理页下具体的物理地址。最终MMU向CPU返回一个物理地址。

上述过程的前提是页命中。

### 写时复制

每个进程都有独立的页表，即独立的虚拟地址空间。

来自不同虚拟地址空间的虚拟地址可以映射到相同的物理地址，即多个地址空间共享了物理地址(又称为对象)。

如果虚拟地址空间的一个区域映射到了共享对象，该区域称为共享区域；反之，映射到私有对象的区域叫做私有区域。

私有对象在生命周期的开始，与共享对象一样，只有一个副本。如果某个进程需要修改虚拟内存且私有对象仍被其他进程共享，对应的PTE显示该页面的权限为只读，将处罚保护故障。故障处理程序在内存中创建该页面的新副本，更新PTE指向新副本，然后恢复页面的可写权限。当故障处理程序返回，再次执行写操作时，就会在新副本上正常执行了。

### 地址空间的内容

<img src="/Users/exocr/Library/Application Support/typora-user-images/image-20200726173824369.png" alt="image-20200726173824369" style="zoom:50%;" />

**栈**：局部临时变量，函数参数，返回地址。

**堆**：动态分配的内存。

**BS段**(.bss)：未初始化且初值非0的全局变量和静态局部变量。

**数据段**(.data)：已初始化且初值非0的全局变量和静态局部变量。

**代码段**(.text)：可执行代码、字符串字面值、只读变量

**简述进程的内存管理？**

每个进程拥有独立的虚拟地址空间，其中包含了代码段、数据段、BS段、堆(heap)、栈(stack)。堆向地址高位扩展、栈向地址地位扩展。堆存放动态分配的区域，栈存放局部临时变量。

### IO多路复用

单个线程管理多个IO流，时分复用

三种实现方式：select、poll、epoll

select：socket注册进select，select轮询并调用被激活的socket，通知用户线程发起读取请求

poll：取消select 1024连接数限制、不修改传入的参数

epoll>poll>select，只有epoll是线程安全

### epoll原理

1. 使用epoll_create创建一个epoll对象epfd(epfd表示一个eventpoll对象)
2. 使用epoll_ctl将需要监视的socket添加到epfd
3. 使用epoll_wait等待数据
4. 使用rdlist就绪队列引用活跃的socket(收到数据的socket)

5. socket收到数据后，中断程序操作eventpoll将socket引用到rdlist
6. 执行到epoll_wait的进程，去读取rdlist中的socket数据，如果rdlist为空则阻塞，不然epoll_wait直接返回

参考博客点[这里](https://blog.csdn.net/jiankunking/article/details/90518647)

### 栈帧

函数调用，在调用栈维护独立的栈帧，包含内容：

+ 函数参数、返回地址
+ 临时变量
+ 函数调用的上下文

栈由高地址向低地址延伸，ebp寄存器-帧指针-栈底，esp寄存器-栈指针-栈顶。

### 连续/随机内存访问

内存访问时，CPU的cache会载入预测的一段连续内存地址。连续内存访问，能提高cache命中率；随机访问则可能会导致多次载入内存数据到cache，降低cache命中率。
[toc]

### 短链接

短链接就是把一个普通的url变成一个较短的url。在限制字符数的场景中，使用短链接能减少url的长度且简洁美观。

短链接的使用过程：用户访问短链接(如http://t.cn/xxxxxx)，请求t.cn对应的服务器，参数为xxxxxx，该服务器在数据库中搜索参数对应的网址，然后使用http 301/302跳转到目标网址。

**自增序列算法**

设置id自增，一个id对应一个url，将十进制的id转换为更高进制的值作为短链接的参数。

**hash**

1. 将长网址 `md5` 生成 128 位的二进制签名串，串分为 4 段，每段 4 个字节
2. 对这四段循环处理，取 4个字节, 将他看成 16 进制串与 0x3fffffff(30位1) 与操作，即超过 30 位的忽略处理
3. 这 30 位分成 6 段，每 5 位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串
4. 总的 `md5` 串可以获得 4 个 6 位串，取里面的任意一个就可作为这个长 url 的短 url 地址

hash算法会存在冲突，但概率很小。

### SSO(Single Sign on)

SSO即单点登录，含义是只需要登录一次，就可以访问互相信任的应用系统。

SSO与传统的登录认证流程不同的是，SSO设置了CAS(Central Authentication Service)，又称为SSO系统，专门用于登录认证，所有业务系统的认证都会跳转到SSO系统进行认真。

SSO认证过程：

1. 用户访问app系统，app系统是需要登录的，但用户现在没有登录。
2. 跳转到CAS server，即SSO登录系统，**以后图中的CAS Server我们统一叫做SSO系统。** SSO系统也没有登录，弹出用户登录页。
3. 用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。
4. SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。
5. app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。
6. 验证通过后，app系统将登录状态写入session并设置app域下的Cookie。

至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。

1. 用户访问app2系统，app2系统没有登录，跳转到SSO。
2. 由于SSO已经登录了，不需要重新登录认证。
3. SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。
4. app2拿到ST，后台访问SSO，验证ST是否有效。
5. 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。

### HTTP 301与302的区别

301 是永久重定向，302暂时重定向

301情景：域名到期、空间服务器更换时等。

302情景：暂时想展示另一个网址的内容。

使用302的潜在风险：一、A暂时重定向到B，搜索引擎虽然抓取的是B内容，但是实际收录的A的网址，这导致A蹭了B的热度，搜索排名上升；二、A自己的内容很烂，就重定向到B，相当于于空手套白狼。

### SSL(Secure Sockets Layer)

SSL是Netscape公司提出的安全协议，利用数据加密、身份验证和消息完整性验证机制，为HTTP传输提供安全性保证。

### TCP慢启动

慢启动是拥塞控制的手段之一，通过设置一个**拥塞窗口(cwnd)**，从而避免大包积压在拥塞的节点。

过程：对于一个刚建立的链接，在三次握手期间接收方通告自己的**接收窗口(rwnd)**，发送方通告自己的**拥塞窗口(cwnd)**，拥塞窗口的初始值通常为4个TCP段，发送端取`min(rwnd, cwnd)`作为发送方的滑动窗口大小，在发送完4个段后拥塞窗口增大一点，之后每次传输完部分数据，拥塞窗口就增大一点。这就是慢启动的过程，尽管带宽足够大仍然受慢启动的影响，在新连接的流量被限制。

TCP的另一机制叫**SSR(Slow-StartRestart)慢启动重启**：在连接空闲一定的时间后重置连接的拥塞窗口。

### HTTP keep-alive

http的keep-alive机制用于延长tcp的连接状态，从最后一次响应结束开始计时keep-alive时间长度，之后如果没有再收到消息将主动发送[FIN, ACK]。tcp连接的双方都有http keep-alive计时，谁时间短谁就先发出关闭消息。

http的keep-alive机制从http 1.1才出现，默认为keep-alive连接。在http 1.0之前每次发送完数据就会断开tcp连接，导致tcp连接的使用非常低效。在keep-alive机制下一个tcp连接能传多个数据。

### TCP keep-alive

有别于HTTP keep-alive，TCP的keep-alive存在的意义是检测对方是否还在。TCP的keep-alive机制有三个参数：闲置时间、侦测包发送时间间隔、侦测包发送次数。在最后一次双方交互数据后开始计时闲置时间，之后如果没有新的交互数据，就会发送侦测包看看对方的回应，如果没有回应就在一定时间间隔后再次发送，总共发送一定次数的侦测包，最终因为无回应而主动关闭TCP连接。

### HTTPS

**与HTTP有什么区别？**

传统的HTTP协议直接与TCP协议进行通讯；HTTPS则是在HTTP与TCP之间增加SSL/TSL(*Secure Sockets Layer/Transport Layer Security*)对数据加密。

**HTTPS工作过程？**

+ 握手阶段(一次握手)

  1.客户端发起握手。*明文传输版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息*。

  2.服务端返回协商结果。*包括选择使用的协议版本 version，选择的加密套件 cipher suite，选择的压缩算法 compression method、随机数 random_S 以及数字证书*。

  3.客户端SSL/TLS验证数字证书的合法性。*验证过程看下一个问题。*

  4.客户端随机生成对称密钥。*传输过程用服务器公钥和商定的加密套件进行加密。*

  5.服务端用密钥解密获取对称密钥，并发送加密的Finish信息。*握手结束。*

+ 通信阶段

  双方使用对称密钥对HTTP数据加密和解密。

**如何验证数字证书的合法性？**

数字证书=认证内容+CA数字签名+Hash序列

认证内容=服务端公钥+签发者+证书到期时间+加密算法+证书用途

CA数字签名=CA密钥(Hash(认证内容))

客户端拿到数字证书，CA数字签名---(CA公钥)--->信息摘要，Compare(Hash(认证内容),  信息摘要)，一致则说明证书合法。

**为什么握手阶段的交互用非对称加密，通信阶段的交互用对称加密**

非对称加密的计算复杂度大于对称加密，字符串越长耗时越长，通信阶段使用对称加密可节约硬件资源的占用。

### Cookie & Session

**cookie**：服务器在本地机器上存储的一小段文本并随每一次请求发送给同一个服务器。cookie分为暂时cookie和永久cookie，取决于是否设置了过期时间。暂时cookie存在于浏览器所占用的内存中，永久cookie以文件形式存储在硬盘中直到过期。

**session**：服务器中一种用于存放用户数据的类HashTable结构。浏览器在第一次请求服务器时，会生成HashTable和session ID。

**两者区别？**

存放位置不同，cookie存储在客户端，session存储在服务端；

存储类型不同，cookie存储字符串，session存储Object类型；

安全性不同，cookie有可能被拦截获取或被篡改，session则不会被截获；

### [CORS](http://www.ruanyifeng.com/blog/2016/04/cors.html)

**跨域资源共享的背景**：有些资源只允许同域或授权的域名才可以访问。

浏览器：所有浏览器都支持跨域请求，通信过程自动完成。

服务器：需要设置CORS接口才允许跨域请求。

### 网络体系结构

**OSI七层协议**：物理层、数据链路层、网络层、运输层、会话层、表示层、应用层

**TCP/IP四层协议**：网络接口层、网际层、运输层、应用层

通常，综合OSI与TCPIP的优点使用五层协议的体系结构。具体为：物理层、数据链路层、网络层、运输层、应用层。一般为了方便，把网络层底下的两层称为网络接口层。

**各层协议举例**：

+ 应用层：TELNET、FTP、SMTP
+ 运输层：TCP、UDP
+ 网络层：IP、ICMP

### 传输层

#### UDP

**特点**

+ UDP是无连接的，即发送数据前无需建立连接。
+ UDP使用尽最大努力交付，即不保证可靠交付，主机无需维持复杂的连接状态。
+ UDP是面向报文的，对应用程序传下来的数据在添加首部后就交给IP层，IP层交上来的数据在去掉首部后就交给应用程序。
+ UDP没有拥塞控制，网络拥塞不会降低源主机的发送速率。
+ UDP支持一对一、一对多、多对一和多对多的交互通信。
+ UDP的首部开销小，只有8字节。

**UDP数据报内容**

首部字段+数据字段

**首部格式**

+ 源端口(2字节)：需要对方回信时选用，不需要时为全0.
+ 目的端口(2字节)
+ 长度(2字节)：UDP数据报的长度，最小值为8字节(只有首部字段)。
+ 校验和(2字节)：UDP检验和是将整个UDP数据报进行校验。

#### TCP的连接建立

+ 被动方创建传输控制块，进入Listen(监听)状态

+ 主动方创建传输控制块，发出连接请求报文，SYN=1；seq=x，进入SYN-SENT(同步已发送)

+ 被动方收到连接报文，返回确认报文，SYN=1；seq=y；ACK=1；ack=x+1，进入SYN-RCVD(同步收到)

+ 主动方收到确认报文，返回确认报文，seq=x+1；ACK=1；ack=y+1，进入ESTABLISHED(建立连接)

  *当主动方返回的确认报文中携带数据，将消耗自己的一个序号*

+ 被动方收到确认报文，进入ESTABLISHED(建立连接)

**为什么要三次握手？**

如果没有第三次握手，被动方直接进入ESTABLISHED，一直等待主动方发数据，造成资源浪费。

#### TCP的连接释放

+ 主动方发出释放报文，FIN=1；seq=u，进入FIN-WAIT-1(终止等待1)

  *FIN报文段必须消耗一个序号*

  *seq=u，u是主动方前面已传送过的数据的最后一个字节的序号加1*

+ 被动方收到释放报文，返回确认报文，seq=v；ACK=1；ack=u+1，进入CLOSE-WAIT(关闭等待)

  *seq=v，v是被动方前面已传送过的数据的最后一个字节的序号加1*

  *CLOSE-WAIT后，主动->被动方向的连接已经关闭*

  *CLOSE-WAIT后，被动方的TCP层通知上层的进程，把最后的数据发送出去*

+ 主动方收到确认报文，进入FIN-WAIT-2(终止等待2)

+ 被动方上层进程发送最后的数据，通知TCP层去发送释放报文，FIN=1；seq=w；ACK=1；ack=u+1，进入LAST-ACK(最后确认)

+ 主动方收到释放报文，返回确认报文，seq=u+1；ACK=1；ack=w+1，并开始倒计时2MSL

  *2MSL内，如果遇到被动方重传释放报文则重置计时器并再次返回确认报文，否则时间耗尽进入CLOSED*

+ 被动方收到确认报文，进入CLOSED

**第四次挥手为什么要等待2MSL？**

原因一：为了保证第四次挥手报文到达被动方。如果被动方收不到确认报文，被动会重传释放报文，主动方如果等待2MSL就肯定能接收到重传报文。

原因二：保证下一个新连接不会不会出现旧连接的报文。主动方发送确认报文后的2SML内，本次连接产生的所有报文都会从网络中消失。

**为什么挥手需要四次？**

TCP是全双工通信，断开的主动方第一次挥手时，被动方可能还在传输数据。断开连接需要双方共同确认，二次挥手仅表示被动方已经知道主动方不再发送数据，第三次挥手则表示被动方通知主动方自己不再发送数据，因此二、三次挥手不能合并。

#### TCP可靠传输的原理

+ 滑动窗口：控制数据传输速率；
+ 超时重传：保证分组到达；
+ 选择确认：减少重传，提高效率；(多数发送方可能不会对选择确认进行回应，仍然会重传)

#### TCP滑动窗口协议

含义：规定TCP传输过程一次发送多少字节的数据，滑动窗口协议是在TCP协议中使用的。

用途：端到端的流量控制。

特性：滑动窗口大小在TCP三次握手后进行协商，传输过程中数据按顺序发送并按顺序确认后，窗口才向后滑动。滑动窗口协议解决了网络传输不可靠的问题，如丢包、重复包、乱序。

原理：

数据包分为四类：已发送、已发送未确认、允许发送未发送、不可发送。发送方和接收方分别维护一个缓冲区，即窗口。缓冲区内的数据将按顺序发送并按顺序确认。

正常情况下，当收到缓冲区第一个数据包的ACK时窗口向后滑动一个位置，新的数据放入缓冲区准备发送。

如果丢包，缓冲区第一个字节的数据在**超时重传**机制下会重传。在拿到该字节的确认之后，窗口后移一位。

**如果发送方第二个字节先到达怎么办？**

假设接收方拿到了第二个字节的数据，但第一个字节的数据还没收到，这时接收方会将第二个字节保留在缓冲区。

发送方如果没收到第一个字节的确认，会超时重传。重传后发送方收到了第一个字节的确认，因为第二个字节早已在缓冲区中，接收方发送完第一个字节的确认，便可以立即发送第二个字节的确认。

如果第二个字节的确认还在路上，发送方那就超时了，发送方就会重传第二个字节。

#### TCP的拥塞控制

含义：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞的定义为：`需求的资源>可用的资源`。

特性：拥塞控制涉及网络中所有的主机、路由器，是全局性的控制。

原理：网络拥塞是所有因素影响的加成，解决单点拥塞没有意义，甚至会更加拥塞。需要从全局综合考虑，分为开环控制和闭环控制。开环即事先设计好方案，系统一旦运行则不可更改。闭环则是基于反馈的自动调整。

方法：慢开始、拥塞避免、快重传、快恢复。

+ 慢开始
  + 开始传输，设置初始拥塞窗口值，即首次发送的字节数。*拥塞窗口以字节为单位，数值一般为1-4个SMSS(最大报文段)，拥塞窗口限制的是一次发送的所有报文段的字节大小之和，其实也可以理解为一个轮次能发送的报文个数。*
  + 接收到一个确认报文，拥塞窗口就会增加，下一轮次发送的总报文大小为增加后的窗口值。*`窗口的增加值=min(N, SMSS)`，N为原先未确认、刚刚收到确认报文所确认的字节数。*
  + 传输轮次并非一轮轮地发送报文，每收到一个确认报文就可以立即发送新报文，轮次概念能很好地体现数据的按序发送和确认。一轮传输所用的时间称为**RTT**，等于从发出该轮次第一个报文至该接收到该轮次最后一个报文的时间。
+ 拥塞避免
  + 拥塞窗口持续增加，会造成网络的拥塞，因此需要设置**慢开始门限**。当拥塞窗口>门限，将停止慢开始算法，改用拥塞避免算法。
  + 每经历一个RTT，拥塞窗口增加1。
  + 假设拥塞窗口值=n时接收方的确认包发生超时，发送方将门限设置为当前窗口的n/2，同时把拥塞窗口重置为初始拥塞窗口值，重新进入慢开始阶段。
+ 快重传
  + 传输中总会有丢包的情况，但网络中并没有发生拥塞。如果没有收到确认报文，发送方会认为网络拥塞而重置拥塞窗口，降低了传输效率。
  + 快重传要求接收方在收到报文后，立即发送确认报文。在发生丢包时，假设M2在传输中丢失，当M3、M4、M5到达时，都要立即发送M1的确认报文，发送方会收到4个重复确认。按规定：收到3个连续的M1重复确认报文，就需要重传M2。
+ 快恢复
  + 发送方接收到3个连续的重复确认，便将门限设置为当前窗口的n/2，同时把窗口值也设置为当前窗口的n/2，从而避免了进入慢开始阶段，提高了传输效率。

### URL解析过程

浏览器输入URL后，经历以下过程后将域名转换成IP：

+ 浏览器查看自己的DNS缓存
+ 递归调用操作系统DNS缓存
+ 递归调用本地域名服务器
+ 本地域名服务器向根域名服务器请求
+ 本地域名服务器向com域名服务器请求
+ 本地域名服务器向权限域名服务器请求

上述顺序中，只要有一步找到域名，便可结束查询。

### 数据加密解密

**1.对称加密**

发送方将明文和密钥经过加密算法处理后，变成密文发送出去。接收方使用相同的密钥和相同算法的逆算法对密文进行解密，才能获取明文。

**2.非对称加密**

加密和解密使用不同的密钥，公钥加密后只能用私钥解密，私钥加密后只能用公钥解密。将公钥分发给多个对象，私有只有自己使用，那么对方发来的消息使用公钥加密后，只有自己才能解密。

**3.数字证书**

数字证书由证书中心(CA)颁发，CA使用自己的私钥将一个公钥和相关信息加密得到数字证书，用于对公钥做认证。

使用场景：

A发送信息需要经过三步：一、使用私钥对明文加密变成密文；二、用Hash函数生成信件摘要(digest)，再使用私钥将摘要加密生成数字签名，附在密文下面；三、向CA申请公钥认证，拿到CA颁布的数字证书，同样附在密文下面。

B接收到消息后，也需要经过三步：一、从数字证书的颁发者那获取CA的公钥，再使用CA公钥对数字证书解密从而拿到A的公钥；二、使用A公钥对数字签名解密从而拿到信件摘要；三、使用A公钥对密文解密从而拿到明文，并对明文做同样的Hash处理，如果Hash结果和拿到的摘要一样则证明数字签名确实是由A签写的。